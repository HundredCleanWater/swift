![image](https://user-images.githubusercontent.com/90129613/201480865-9e6b7004-c3eb-4d4a-b99c-6b62bfa10239.png)

### @IBOutlet과 @IBAction

@IBOutlet과 @IBAction을 모아서 인터페이스 빌더(Interface Builder) 어노테이션이라고 부릅니다.   
@IBOulet은 프로퍼티에, @IBAction은 메소드에 각각 추가되는 어노테이션인데 처음 앱이 빌드 될 때 컴파일러가 체크하고 연결 정보를 찾아 인터페이스 빌더의 객체와 서로 연결을 해줍니다. 

### @IBOulet - 객체의 참조

@IBOulet은 화면상의 객체를 소스 코드에서 참조하기 위해 사용하는 어노테이션입니다.   
주로 객체의 속성을 제어할 목적으로 클래스의 프로퍼티에 연결합니다.

이때, 인터페이스 빌더의 객체와 클래스의 프로퍼티는 서로 타입이 일치해야 합니다.(ex. IB의 객체가 레이블이었다면 소스 코드에서는 이 레이블과 동일한 객체 타입인 UILabel 클래스 타입으로 정의)

@IBOulet으로 정의된 프로퍼티를 **아울렛 변수**라고 부릅니다.

![image](https://user-images.githubusercontent.com/90129613/201480898-a52af1a3-9ec4-48a6-9f3a-4763657b2e96.png)

위와 같이 Outlet 변수 연결은 두 가지의 방법이 있습니다.

1\. 인터페이스 빌더상의 객체를 보조 에디터의 클래스 위로 끌어다 놓는것(마우스 오른쪽 버튼 or 컨트롤 + 마우스 왼쪽버튼)

![image](https://user-images.githubusercontent.com/90129613/201480938-181561d6-7210-463e-8ff4-80b312bed2b1.png)

2\. 먼저 소스코드를 작성 한 후 StoryBoard의 객체와 연결

![image](https://user-images.githubusercontent.com/90129613/201480958-eb38599d-deb1-4fa2-880b-c997be5a1a0e.png)

이렇게 연결 할 때 입력하는 내용과 관련하여 주의해야 할 항목이 있습니다. 바로 제일 아래에 있는 \[Storage\]항목 입니다.

Storg/Weak 두 가지 값 중에서 선택 할 수 있는데, 만약 Weak를 선택했을 경우에는 @IBOulet 속성 변수의 정의 앞에 weak 키워드가 추가됩니다.

![image](https://user-images.githubusercontent.com/90129613/201480987-cc87f0db-63aa-49c8-9d81-46faa003e73e.png)
![image](https://user-images.githubusercontent.com/90129613/201481025-58335afe-1fdb-4302-95f6-f6d0ae143cf5.png)
- Stroage에서 Weak로 설정하니 weak 키워드가 추가 된 걸 확인 할 수 있습니다.

반면, Strong 타입으로 정의된 속성 변수는 아무 키워드도 추가되지 않습니다. 이는 속성 변수가 기본적으로 Strong 타입이라는 뜻입니다.

Strong과 Weak 타입의 차이는 메모리 회수 정책에 있습니다. 일반적으로, 변수나 상수는 다른 곳에서 참조되고 있을 경우 메모리에서 제거되지 않는 것이 원칙이지만, **Weak 타입으로 선언된 변수나 상수는** 다른 곳에서 참조되고 있더라도 시스템이 **임의로 메모리에서 제거** 할 수 있습니다. 이로 인해 Weak 타입으로 선언된 변수나 상수에서는 간혹 저장해둔 값이 사라지는 현상이 발생하기도 합니다. 

 하지만 이러한 단점에도 불구하고 Weak 타입이 필요한 이유는 **메모리 관리의 이슈** 때문입니다. Strong 타입 객체들끼리 상호 참조를 한다면, 참조 카운트가 0이 되지 않으므로 애플리케이션이 실행되는 한 영원히 메모리에서 제거되지 않습니다. 이는 **메모리 누수**로 이어지기때문에 한쪽을 Weak 타입으로 지정하여 상호 참조로부터 벗어날 수 있게 됩니다. 

### @IBAction - 객체의 이벤트 언어

@IBAction은 객체의 이벤트를 제어할 때 사용하는 어노테이션입니다. 버튼을 눌렀을 때 화면을 이동시키거나 메시지를 띄워 주는 등, 특정 객체에서 지정된 이벤트가 발생했을 때 우리가 의도하는 일련의 프로세스를 실행하게 할 목적을 가집니다. 이를 위해 어노테이션은 메소드와 함께 사용되는데, 이를 **액션 메소드**라 부릅니다.

가령, 버튼을 예로 들었을 때 버튼 객체는 배경 색상,크기,모양,텍스트 내용 등 정적인 상태를 표현할 수 있는 요소인 **프로퍼티(Property)**와 터치,클릭 등 동적인 상태를 처리하는 **메소드**를 가지고 있습니다. **버튼의 외형 및 성질에 관한 값을 변경**하려면 프로퍼티와 함께 사용되는 **@IBOulet**을 사용해야 하고, **사용자의 액션이 발생했을  때 수행**하야 하는 작업이 있다면 메소드와 함께 사용되는 **@IBAction** 어노테이션을 사용해야 합니다. 

단, 대부분의 객체와 연결할 수 있는 아울렛 변수와 달리 액션 메소드는 버튼이나 테이블 셀 등 사용자와 상호 반응할 수 있는 객체를 연결할 때만 사용할 수 있다는 제한이 있습니다. 생성하는 방법은 아울렛 변수를 생성하는 과정과 동일하기때문에 넘어가도록 하겠습니다. 

액션 메소드를 생성할 때 설정해야 하는 항목 중 하나는 다양한 이벤트(버튼 터치, 드래그 등) 중에서 어떤 것을 감지하여 실행할 것이냐 입니다.

![image](https://user-images.githubusercontent.com/90129613/201481057-1e855a41-5ef2-483b-bb55-e4610807e069.png)

### 마무리

마무리로 아울렛 변수와 액션 메소드의 연결 차이점을 보고 끝내겠습니다.

| 연결 용도 |   | 설정창 항목 |   | 소스 코드 결과 |
| --- | --- | --- | --- | --- |
| 객체의 속성을 제어 |  -> | Outlet 선택 |  -> | @IBOutlet Property |
| 객체의 이벤트를 연결 |  -> | Action 선택 | \-> | @IBAction Method |

출처: 꼼꼼한 재은씨의 Swift:기본편